"""Utility to sevrve as Publisher of LE audio log event."""
import bttc
from datetime import timedelta
import logging
import os
from typing import List

import constants
import errors

from le_audio_parsing_data import CollectOutputResult
from observer.le_audio_log_observer import Observer
import utils


_COLLECTION_OUTPUT_FILE_PATH = '/tmp/log_event_publisher_{observer_name}.txt'
_ENV_LOGCAT_MONITOR_TIME = 'LE_AUDIO_PERF_LOGCAT_MONITOR_TIME'


class LogEventPublisher():
  """A class to serve as log event publisher.

    Attributes:
      observers: List to hold registered observer.
      output: Dataclass to hold the output data generated by the log parser.
      log: Logger object literally.
  """

  def __init__(self):
    """Initial setup test."""
    self.observers: List[Observer] = []
    self.output = CollectOutputResult()
    self.log = logging.getLogger(__name__)

  def register_observer(self, observer: Observer):
    """Saves the registered observer."""
    self.observers.append(observer)

  @utils.pdb_able
  def start_to_search(self, input_file_path: str,
                      output_file_path: str = 'report') -> CollectOutputResult:
    """Opens the input file and analyzes the input log file.

    Args:
      input_file_path: Log file path to analyze.
      output_file_path: File path to output result.

    Returns:
      captured_messages : List to store the captured messages.
    """
    line_num = 0
    debug_lin_num = 0
    if input_file_path.startswith('device:'):
      # Read logcat directly from device
      input_info = input_file_path.split(':')
      device_serial = input_info[1].strip()
      output_collected_log_path = f'/tmp/collected_log_from_{device_serial}.txt'
      if len(input_info) > 2:
        output_collected_log_path = input_info[2]

      if device_serial.startswith('localhost_'):
        device_serial = device_serial.replace('_', ':')
        self.log.info('Device serial: %s', device_serial)

      dut = bttc.get(device_serial)
      # Default logcat monitoring time is 1 hr.
      logcat_monitoring_time_sec = int(
          os.environ.get(_ENV_LOGCAT_MONITOR_TIME, 60 * 60))
      time_info = timedelta(seconds=logcat_monitoring_time_sec)
      self.log.info(
          f'Monitoring logcat message for %s... '
          f'(You could use environment "%s" to change this setting)',
          time_info, _ENV_LOGCAT_MONITOR_TIME)
      try:
        with open(output_collected_log_path, 'w') as fw:
          for line_num, line in enumerate(
              dut.gm.follow_logcat_within(
                  time_sec=logcat_monitoring_time_sec,
                  logcat_args='-b system -b events -b main')):
            fw.write(f'{line}\n')
            if ' D ' in line:
              debug_lin_num += 1

            for observer in self.observers:
              captured_messages = observer.notify(line)
              if captured_messages is not None:
                self.output.collection.extend(captured_messages)
                break
      except KeyboardInterrupt as ex:
        self.log.info('Stop monitoring logcat!')
        self.log.info('Output collected logcat message into %s!', output_collected_log_path)
      except Exception as ex:
        self.log.error('Failed at line=%s (%s): %s', line_num, line, ex)
        raise
    else:
      with open(input_file_path, 'r', encoding='utf-8', errors='ignore') as fo:
        try:
          for line_num, line in enumerate(fo):
            if ' D ' in line:
              debug_lin_num += 1

            for observer in self.observers:
              captured_messages = observer.notify(line)
              if captured_messages is not None:
                self.output.collection.extend(captured_messages)
                break
        except Exception as ex:
          self.log.error('Failed at line=%s (%s): %s', line_num, line, ex)
          raise

    for observer in self.observers:
      output_collection_file_path = (
            _COLLECTION_OUTPUT_FILE_PATH.format(
                observer_name=observer.__class__.__name__))
      self.log.info(
          'Output collection of captured message to %s...',
          output_collection_file_path)
      with open(output_collection_file_path, 'w') as fw:
        for raw_data in observer.global_raw_data:
          fw.write(f'{raw_data}\n')

    # TODO: The original design doesn't take multiple observers situation
    #   into consideration and use the last observer from for loop which
    #   is buggy. We have to improve this problem soon.
    try:
      observer.is_parsing_complete()
      self.output.drop_num = observer.drop_num
      if not self.output.collection:
        raise errors.EmptyCollectionError()
    except Exception as ex:
      if debug_lin_num == 0:
        constants.print_warning('No debug level message')

      raise ex

    # Output error collection to file for further analysis
    self.print_to_file(output_file_path)

  def print_to_file(self, output_file_path: str) -> None:
    """Prints the result to given output file.

     Steps:
      1. Gets the output title list for checking the output format.
      2. Save the output results to a .txt file.
      3. Save the output results to a .csv file.

    Args:
      output_file_path: File path to output result.
    """

    self.output.get_title_list()
    self.output.save_output_messages(output_file_path)
    self.output.save_output_messages_to_csv(output_file_path)
